'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _debug2 = require('debug');

var _debug3 = _interopRequireDefault(_debug2);

var _awsSdk = require('aws-sdk');

var _awsSdk2 = _interopRequireDefault(_awsSdk);

var _cloudwatchEventFormatter = require('./cloudwatch-event-formatter');

var _cloudwatchEventFormatter2 = _interopRequireDefault(_cloudwatchEventFormatter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug3.default)('winston-aws-cloudwatch:CloudWatchClient');

const DEFAULT_OPTIONS = {
  awsConfig: null,
  formatLog: null,
  formatLogItem: null,
  createLogGroup: false,
  createLogStream: false,
  submissionRetryCount: 1
};

class CloudWatchClient {
  constructor(logGroupName, logStreamName, options) {
    debug('constructor', { logGroupName, logStreamName, options });
    this._logGroupName = logGroupName;
    this._logStreamName = logStreamName;
    this._options = (0, _assign2.default)({}, DEFAULT_OPTIONS, options);
    this._formatter = new _cloudwatchEventFormatter2.default(this._options);
    this._sequenceToken = null;
    this._client = new _awsSdk2.default.CloudWatchLogs(this._options.awsConfig);
    this._initializing = null;
  }

  submit(batch) {
    debug('submit', { batch });
    return this._initialize().then(() => this._doSubmit(batch, 0));
  }

  _initialize() {
    if (this._initializing == null) {
      this._initializing = this._maybeCreateLogGroup().then(() => this._maybeCreateLogStream());
    }
    return this._initializing;
  }

  _maybeCreateLogGroup() {
    if (!this._options.createLogGroup) {
      return _promise2.default.resolve();
    }
    const params = {
      logGroupName: this._logGroupName
    };
    return this._client.createLogGroup(params).promise().catch(err => this._allowResourceAlreadyExistsException(err));
  }

  _maybeCreateLogStream() {
    if (!this._options.createLogStream) {
      return _promise2.default.resolve();
    }
    const params = {
      logGroupName: this._logGroupName,
      logStreamName: this._logStreamName
    };
    return this._client.createLogStream(params).promise().catch(err => this._allowResourceAlreadyExistsException(err));
  }

  _allowResourceAlreadyExistsException(err) {
    return err.code === 'ResourceAlreadyExistsException' ? _promise2.default.resolve() : _promise2.default.reject(err);
  }

  _doSubmit(batch, retryCount) {
    return this._maybeUpdateSequenceToken().then(() => this._putLogEventsAndStoreSequenceToken(batch)).catch(err => this._handlePutError(err, batch, retryCount));
  }

  _maybeUpdateSequenceToken() {
    return this._sequenceToken != null ? _promise2.default.resolve() : this._fetchAndStoreSequenceToken();
  }

  _handlePutError(err, batch, retryCount) {
    if (err.code !== 'InvalidSequenceTokenException') {
      return _promise2.default.reject(err);
    }
    if (retryCount >= this._options.submissionRetryCount) {
      const error = new Error('Invalid sequence token, will retry');
      error.code = 'InvalidSequenceTokenException';
      return _promise2.default.reject(error);
    }
    this._sequenceToken = null;
    return this._doSubmit(batch, retryCount + 1);
  }

  _putLogEventsAndStoreSequenceToken(batch) {
    return this._putLogEvents(batch).then(({ nextSequenceToken }) => this._storeSequenceToken(nextSequenceToken));
  }

  _putLogEvents(batch) {
    const sequenceToken = this._sequenceToken;
    debug('putLogEvents', { batch, sequenceToken });
    const params = {
      logGroupName: this._logGroupName,
      logStreamName: this._logStreamName,
      logEvents: batch.map(item => this._formatter.formatLogItem(item)),
      sequenceToken
    };
    return this._client.putLogEvents(params).promise();
  }

  _fetchAndStoreSequenceToken() {
    debug('fetchSequenceToken');
    return this._findLogStream().then(({ uploadSequenceToken }) => this._storeSequenceToken(uploadSequenceToken));
  }

  _storeSequenceToken(sequenceToken) {
    debug('storeSequenceToken', { sequenceToken });
    this._sequenceToken = sequenceToken;
    return sequenceToken;
  }

  _findLogStream(nextToken) {
    debug('findLogStream', { nextToken });
    const params = {
      logGroupName: this._logGroupName,
      logStreamNamePrefix: this._logStreamName,
      nextToken
    };
    return this._client.describeLogStreams(params).promise().then(({ logStreams, nextToken }) => {
      const match = logStreams.find(({ logStreamName }) => logStreamName === this._logStreamName);
      if (match) {
        return match;
      }
      if (nextToken == null) {
        throw new Error('Log stream not found');
      }
      return this._findLogStream(nextToken);
    });
  }
}
exports.default = CloudWatchClient;