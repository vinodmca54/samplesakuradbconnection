'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _debug2 = require('debug');

var _debug3 = _interopRequireDefault(_debug2);

var _bottleneck = require('bottleneck');

var _bottleneck2 = _interopRequireDefault(_bottleneck);

var _queue = require('./queue');

var _queue2 = _interopRequireDefault(_queue);

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug3.default)('winston-aws-cloudwatch:Relay');

const DEFAULT_OPTIONS = {
  submissionInterval: 2000,
  batchSize: 20
};

class Relay extends _events.EventEmitter {
  constructor(client, options) {
    super();
    debug('constructor', { client, options });
    this._client = client;
    this._options = (0, _assign2.default)({}, DEFAULT_OPTIONS, options);
    this._limiter = null;
    this._queue = null;
  }

  start() {
    debug('start');
    if (this._queue) {
      throw new Error('Already started');
    }
    this._limiter = new _bottleneck2.default(1, this._options.submissionInterval, 1);
    this._queue = new _queue2.default();
    // Initial call to postpone first submission
    this._limiter.schedule(() => _promise2.default.resolve());
  }

  submit(item) {
    this._queue.push(item);
    this._scheduleSubmission();
  }

  _scheduleSubmission() {
    debug('scheduleSubmission');
    this._limiter.schedule(() => this._submit());
  }

  _submit() {
    if (this._queue.size === 0) {
      debug('submit: queue empty');
      return _promise2.default.resolve();
    }
    const batch = this._queue.head(this._options.batchSize);
    debug(`submit: submitting ${batch.length} item(s)`);
    return this._client.submit(batch).then(() => this._onSubmitted(batch), err => this._onError(err, batch)).then(() => this._scheduleSubmission());
  }

  _onSubmitted(batch) {
    debug('onSubmitted', { batch });
    this._queue.remove(batch.length);
    for (let i = 0; i < batch.length; ++i) {
      const item = batch[i];
      item.callback(null, true);
    }
  }

  _onError(err, batch) {
    debug('onError', { error: err });
    if (err.code === 'DataAlreadyAcceptedException') {
      // Assume the request got replayed and remove the batch
      this._queue.remove(batch.length);
    } else if (err.code === 'InvalidSequenceTokenException') {
      // Keep retrying
    } else {
      this.emit('error', err);
    }
  }
}
exports.default = Relay;