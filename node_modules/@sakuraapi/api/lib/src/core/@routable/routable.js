"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
require("reflect-metadata");
const basic_handlers_1 = require("../../handlers/basic-handlers");
const injectable_1 = require("../@injectable/injectable");
const _model_1 = require("../@model");
const debug = {
    normal: require('debug')('sapi:routable')
};
const httpMethodMap = {
    delete: 'delete',
    get: 'get',
    getAll: 'get',
    post: 'post',
    put: 'put'
};
exports.routableSymbols = {
    authenticators: Symbol('authenticators'),
    changeSapi: Symbol('changeSapi'),
    isSakuraApiRoutable: Symbol('isSakuraApiRoutable'),
    model: Symbol('model'),
    routes: Symbol('routes'),
    sapi: Symbol('sapi')
};
function Routable(options) {
    options = options || {};
    options.blackList = options.blackList || [];
    options.baseUrl = options.baseUrl || '';
    return (target) => {
        debug.normal(`@Routable decorating '${target.name}' with options: %o`, options);
        debug.normal(`\t@Routable options.model set to ${(options.model || {}).name}`);
        if (options.model && !options.model[_model_1.modelSymbols.isSakuraApiModel]) {
            throw new Error(`${target.name} is not decorated by @Model and therefore cannot be used as a model for`
                + ` @Routable`);
        }
        if ((options.suppressApi || options.exposeApi) && !options.model) {
            throw new Error(`If @Routable '${target.name}' defines a 'suppressApi' or 'exposeApi' option, then a model`
                + ` option with a valid @Model must also be provided`);
        }
        if (options.suppressApi && options.exposeApi) {
            throw new Error(`@Routable '${target.name}' cannot have both 'suppressApi' and 'exposeApi' set at the same time`);
        }
        debug.normal(`\tproxying constructor`);
        const newConstructor = new Proxy(target, {
            construct: (t, args, nt) => {
                debug.normal(`\tconstructing ${target.name}`);
                const diArgs = injectable_1.getDependencyInjections(target, t, target[exports.routableSymbols.sapi]);
                const constructorProxy = Reflect.construct(t, diArgs, nt);
                const beforeAll = bindHandlers(constructorProxy, options.beforeAll);
                const afterAll = bindHandlers(constructorProxy, options.afterAll);
                const routes = addRoutesForRouteMethods(constructorProxy, beforeAll, afterAll);
                if (options.model) {
                    debug.normal(`\t\tbound to model, adding default routes`);
                    addRouteHandler('get', basic_handlers_1.getRouteHandler, routes, beforeAll, afterAll, constructorProxy);
                    addRouteHandler('getAll', basic_handlers_1.getAllRouteHandler, routes, beforeAll, afterAll, constructorProxy);
                    addRouteHandler('put', basic_handlers_1.putRouteHandler, routes, beforeAll, afterAll, constructorProxy);
                    addRouteHandler('post', basic_handlers_1.postRouteHandler, routes, beforeAll, afterAll, constructorProxy);
                    addRouteHandler('delete', basic_handlers_1.deleteRouteHandler, routes, beforeAll, afterAll, constructorProxy);
                }
                constructorProxy[exports.routableSymbols.routes] = routes;
                return constructorProxy;
            }
        });
        decorateWithAuthenticators(newConstructor);
        decorateWithIdentity(newConstructor);
        decorateWithSapi(newConstructor);
        if (options.model) {
            newConstructor.prototype[exports.routableSymbols.model] = () => {
                return newConstructor[exports.routableSymbols.sapi].getModelByName(options.model.name);
            };
        }
        return newConstructor;
        function addRoutesForRouteMethods(constructorProxy, beforeAll, afterAll) {
            const routes = [];
            debug.normal(`\t\tprocessing methods for '${target.name}'`);
            for (const methodName of Object.getOwnPropertyNames(Object.getPrototypeOf(constructorProxy))) {
                if (!Reflect.getMetadata(`hasRoute.${methodName}`, constructorProxy)) {
                    continue;
                }
                if (options.blackList.indexOf(methodName) > -1) {
                    debug.normal(`\t\t\t${methodName} is black listed; skipping`);
                    continue;
                }
                debug.normal(`\t\t\t${methodName}`);
                const routeAuthenticators = Reflect.getMetadata(`authenticators.${methodName}`, constructorProxy);
                const authenticators = [...routeAuthenticators, ...newConstructor[exports.routableSymbols.authenticators]];
                const afterMeta = Reflect.getMetadata(`after.${methodName}`, constructorProxy);
                const after = bindHandlers(constructorProxy, afterMeta);
                const beforeMeta = Reflect.getMetadata(`before.${methodName}`, constructorProxy);
                const before = bindHandlers(constructorProxy, beforeMeta);
                let endPoint = path
                    .join(options.baseUrl, Reflect.getMetadata(`path.${methodName}`, constructorProxy))
                    .replace(/\/$/, '');
                if (!endPoint.startsWith('/')) {
                    endPoint = '/' + endPoint;
                }
                const routerData = {
                    after,
                    afterAll,
                    authenticators,
                    before,
                    beforeAll,
                    f: Reflect
                        .getMetadata(`function.${methodName}`, constructorProxy)
                        .bind(constructorProxy),
                    httpMethod: Reflect.getMetadata(`httpMethod.${methodName}`, constructorProxy),
                    method: methodName,
                    name: target.name,
                    path: endPoint,
                    routable: constructorProxy
                };
                debug.normal(`\t\t\thandler added: '%o'`, routerData);
                routes.push(routerData);
            }
            return routes;
        }
        function addRouteHandler(method, handler, routes, beforeAll, afterAll, constructorProxy) {
            if (!options.suppressApi && !options.exposeApi) {
                routes.push(generateRoute(method, handler, beforeAll, afterAll, constructorProxy));
                return;
            }
            if (options.exposeApi && options.exposeApi.indexOf(method) > -1) {
                routes.push(generateRoute(method, handler, beforeAll, afterAll, constructorProxy));
                return;
            }
            const isSuppressed = options.suppressApi && (typeof options.suppressApi === 'boolean')
                ? options.suppressApi
                : (options.suppressApi || []).indexOf(method) > -1;
            if (!isSuppressed && !options.exposeApi) {
                routes.push(generateRoute(method, handler, beforeAll, afterAll, constructorProxy));
                return;
            }
        }
        function generateRoute(method, handler, beforeAll, afterAll, constructorProxy) {
            const routePath = ((method === 'get' || method === 'put' || method === 'delete')
                ? `/${(options.baseUrl || options.model.name.toLowerCase())}/:id`
                : `/${options.baseUrl || options.model.name.toLowerCase()}`);
            const diModel = newConstructor[exports.routableSymbols.sapi].getModelByName(options.model.name);
            const routerData = {
                afterAll,
                authenticators: newConstructor[exports.routableSymbols.authenticators],
                beforeAll,
                f: handler.bind(diModel),
                httpMethod: httpMethodMap[method],
                method: handler.name,
                name: target.name,
                path: routePath,
                routable: constructorProxy
            };
            debug.normal(`\t\t\tbuiltin handler added: '%o'`, routerData);
            return routerData;
        }
        function bindHandlers(constructorProxy, handlers) {
            const boundHandlers = [];
            if (!handlers) {
                return;
            }
            if (!Array.isArray(handlers)) {
                handlers = [handlers];
            }
            for (const handler of handlers) {
                boundHandlers.push(handler.bind(constructorProxy));
            }
            return boundHandlers;
        }
    };
    function decorateWithAuthenticators(target) {
        options.authenticator = options.authenticator || [];
        if (!Array.isArray(options.authenticator)) {
            options.authenticator = [options.authenticator];
        }
        target[exports.routableSymbols.authenticators] = options.authenticator;
    }
    function decorateWithIdentity(target) {
        Reflect.defineProperty(target.prototype, exports.routableSymbols.isSakuraApiRoutable, {
            value: true,
            writable: false
        });
        Reflect.defineProperty(target, exports.routableSymbols.isSakuraApiRoutable, {
            value: true,
            writable: false
        });
    }
    function decorateWithSapi(target) {
        target[exports.routableSymbols.sapi] = null;
        Reflect.defineProperty(target, 'sapi', {
            configurable: false,
            enumerable: false,
            get: () => target[exports.routableSymbols.sapi]
        });
        Reflect.defineProperty(target.prototype, 'sapi', {
            configurable: false,
            enumerable: false,
            get: () => target[exports.routableSymbols.sapi]
        });
        Reflect.defineProperty(target, 'sapiConfig', {
            configurable: false,
            enumerable: false,
            get: () => (target[exports.routableSymbols.sapi] || {}).config
        });
        Reflect.defineProperty(target.prototype, 'sapiConfig', {
            configurable: false,
            enumerable: false,
            get: () => (target[exports.routableSymbols.sapi] || {}).config
        });
    }
}
exports.Routable = Routable;
//# sourceMappingURL=routable.js.map