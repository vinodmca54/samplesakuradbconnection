"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const mongodb_1 = require("mongodb");
const debug = {
    normal: require('debug')('sapi:SakuraMongoDbConnection'),
    verbose: require('debug')('sapi:SakuraMongoDbConnection:verbose')
};
class SakuraMongoDbConnection {
    constructor() {
        this.connections = new Map();
        this.dbs = new Map();
    }
    addConnection(dbName, uri, options) {
        debug.normal(`.addConnection dbName: '${dbName}', uri: '${uri}', options:`, options);
        this.connections.set(dbName, { uri, options });
        debug.verbose(`.addConnection connections: '%O'`, this.connections);
    }
    connect(dbName, uri, options) {
        return __awaiter(this, void 0, void 0, function* () {
            debug.normal(`.connect dbName: '${dbName}', uri: '${uri}', options:`, options);
            let db;
            db = this.getDb(dbName) || null;
            if (db) {
                debug.normal(`.connect dbName: '${dbName}' already connected`);
                return db;
            }
            this.dbs.set(dbName, {});
            this.connections.set(dbName, { uri, options });
            try {
                db = yield mongodb_1.MongoClient.connect(uri, options);
                debug.normal(`.connect dbName: '${dbName}' connected`);
                this.dbs.set(dbName, db);
                debug.verbose('.connect dbs: %O', this.dbs);
                return db;
            }
            catch (err) {
                debug.normal(`.connect dbName: '${dbName}' error:`, err);
                this.dbs.delete(dbName);
                return Promise.reject(err);
            }
        });
    }
    connectAll() {
        return __awaiter(this, void 0, void 0, function* () {
            debug.normal('.connectAll start');
            const wait = [];
            for (const connection of this.connections) {
                wait.push(this.connect(connection[0], connection[1].uri, connection[1].options));
            }
            try {
                const results = Promise.all(wait);
                debug.normal('.connectAll done');
                return results;
            }
            catch (err) {
                debug.normal(`.connectAll error:`, err);
                return Promise.reject(err);
            }
        });
    }
    close(dbName, forceClose) {
        return __awaiter(this, void 0, void 0, function* () {
            const db = this.dbs.get(dbName);
            debug.normal(`.close dbName:'${dbName}', forceClose: ${forceClose}, connection found: ${!!db}`);
            if (db) {
                this.connections.delete(dbName);
                this.dbs.delete(dbName);
                return db.close(forceClose);
            }
            return;
        });
    }
    closeAll() {
        return __awaiter(this, void 0, void 0, function* () {
            debug.normal('.closeAll called');
            const wait = [];
            for (const db of this.dbs) {
                wait.push(db[1].close());
            }
            try {
                yield Promise.all(wait);
                debug.normal('.closeAll done');
            }
            catch (err) {
                debug.normal('.closeAll error:', err);
                return Promise.reject(err);
            }
        });
    }
    getDb(dbName) {
        const result = this.dbs.get(dbName);
        debug.normal(`.getDb dbName: '${dbName}', found: ${!!result}`);
        debug.verbose(`.getDb dbs: %O`, this.dbs);
        return result;
    }
    getConnection(dbName) {
        const result = this.connections.get(dbName);
        debug.normal(`.getConnection dbName:'${dbName}', found: ${!!result}`);
        return result;
    }
    getConnections() {
        return this.connections;
    }
}
exports.SakuraMongoDbConnection = SakuraMongoDbConnection;
//# sourceMappingURL=sakura-mongo-db-connection.js.map