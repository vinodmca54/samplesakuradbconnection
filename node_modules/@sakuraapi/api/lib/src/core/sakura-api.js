"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const debugInit = require("debug");
const express = require("express");
const express_1 = require("express");
const http = require("http");
const boot_1 = require("../boot");
const _1 = require("./");
const _model_1 = require("./@model");
const _routable_1 = require("./@routable");
const plugins_1 = require("./plugins");
const debug = {
    authenticators: debugInit('sapi:authenticators'),
    models: debugInit('sapi:models'),
    normal: debugInit('sapi:SakuraApi'),
    providers: debugInit('sapi:providers'),
    routables: debugInit('sapi:routables'),
    route: debugInit('sapi:route')
};
class SakuraApi {
    constructor(options) {
        this._address = '127.0.0.1';
        this._port = 3000;
        this.authenticators = new Map();
        this.lastErrorHandlers = [];
        this.listenCalled = false;
        this.middlewareHandlers = {};
        this.models = new Map();
        this.providers = new Map();
        this.routables = new Map();
        this.routeQueue = new Map();
        debug.normal('.constructor started');
        this._baseUrl = options.baseUrl || '/';
        this.config = (!options.config)
            ? new boot_1.SakuraApiConfig().load(options.configPath) || {}
            : options.configPath;
        this._dbConnections = (options.dbConfig)
            ? this._dbConnections = options.dbConfig
            : this._dbConnections = boot_1.SakuraApiConfig.dataSources(this.config);
        this._app = options.app || express();
        this._server = http.createServer(this.app);
        this._address = (this.config.server || {}).address || this._address;
        this._port = (this.config.server || {}).port || this._port;
        this.registerProviders(options);
        this.registerPlugins(options);
        this.registerModels(options);
        this.registerRoutables(options);
        debug.normal('.constructor done');
    }
    get address() {
        return this._address;
    }
    get app() {
        return this._app;
    }
    get baseUrl() {
        return this._baseUrl;
    }
    get config() {
        return this._config;
    }
    set config(config) {
        this._config = config;
    }
    get dbConnections() {
        return this._dbConnections;
    }
    get port() {
        return this._port;
    }
    get server() {
        return this._server;
    }
    addMiddleware(fn, order = 0) {
        debug.normal(`.addMiddleware called: '${(fn || {}).name}', orderr: ${order}`);
        if (!fn) {
            debug.normal(`handler rejected because it's null or undefined`);
            return;
        }
        if (!this.middlewareHandlers[order]) {
            this.middlewareHandlers[order] = [];
        }
        this.middlewareHandlers[order].push(fn);
    }
    addLastErrorHandlers(fn) {
        debug.normal('.addMiddleware called');
        this.lastErrorHandlers.push(fn);
    }
    close() {
        debug.normal('.close called');
        return new Promise((resolve, reject) => {
            this
                .server
                .close((err) => {
                if (err && err.message !== 'Not running') {
                    debug.normal('.close error', err);
                    return reject(err);
                }
                debug.normal('.close done');
                resolve();
            });
        });
    }
    listen(listenProperties) {
        return __awaiter(this, void 0, void 0, function* () {
            debug.route(`.listen called with serverConfig:`, listenProperties);
            debug.route(`.listen setting baseUri to ${this._baseUrl}`);
            listenProperties = listenProperties || {};
            this._address = listenProperties.address || this._address;
            this._port = listenProperties.port || this._port;
            let router;
            if (!this.listenCalled) {
                debug.route(`\t.listen first time call, adding app middleware and route handlers`);
                for (const key of Object.keys(this.middlewareHandlers).sort()) {
                    const handlers = this.middlewareHandlers[key];
                    this.app.use(handlers);
                }
                this.app.use(catchBodyParserErrors);
                this.app.use(handleResponseLocals);
                if (this.lastErrorHandlers) {
                    for (const handler of this.lastErrorHandlers) {
                        this.app.use(handler);
                    }
                }
                this.app.use(this._baseUrl, (req, res, next) => {
                    router(req, res, next);
                });
                this.listenCalled = true;
            }
            router = express_1.Router();
            debug.route('\t.listen processing route queue');
            for (const route of this.routeQueue.values()) {
                debug.route('\t\t.listen route %o', route);
                let routeHandlers = [
                    (req, res, next) => {
                        res.locals.routable = route.routable;
                        next();
                    }
                ];
                if (route.authenticators.length > 0) {
                    routeHandlers.push(authHandler.bind(this)(route));
                }
                if (route.beforeAll) {
                    routeHandlers = [...routeHandlers, ...route.beforeAll];
                }
                if (route.before) {
                    routeHandlers = [...routeHandlers, ...route.before];
                }
                routeHandlers.push(route.f);
                if (route.after) {
                    routeHandlers = [...routeHandlers, ...route.after];
                }
                if (route.afterAll) {
                    routeHandlers = [...routeHandlers, ...route.afterAll];
                }
                routeHandlers.push(resLocalsHandler);
                router[route.httpMethod](route.path, routeHandlers);
            }
            if (this.dbConnections) {
                yield this.dbConnections.connectAll();
                return listen.bind(this)();
            }
            else {
                return listen.bind(this)();
            }
            function authHandler(route) {
                return (req, res, next) => __awaiter(this, void 0, void 0, function* () {
                    let firstFailure;
                    let firstFailureAuthenticatorName;
                    let currentAuthenticatorName;
                    try {
                        for (const authenticatorConstructor of route.authenticators) {
                            currentAuthenticatorName = authenticatorConstructor.name;
                            const authenticator = this.getAuthenticator(authenticatorConstructor);
                            const result = yield authenticator.authenticate(req, res);
                            if (!result.success && !firstFailure) {
                                firstFailure = result;
                                firstFailureAuthenticatorName = authenticatorConstructor.name;
                            }
                            else if (result.success) {
                                if (this.onAuthenticationError) {
                                    const override = yield this.onAuthenticationSuccess(req, res, result, currentAuthenticatorName);
                                    if (override && override.status) {
                                        result.status = override.status;
                                    }
                                    if (override && override.data) {
                                        result.data = override.data;
                                    }
                                }
                                return next();
                            }
                        }
                        if (this.onAuthenticationError) {
                            const override = yield this.onAuthenticationError(req, res, firstFailure, firstFailureAuthenticatorName);
                            if (override && override.status) {
                                firstFailure.status = override.status;
                            }
                            if (override && override.data) {
                                firstFailure.data = override.data;
                            }
                        }
                        res
                            .status(firstFailure.status)
                            .json(firstFailure.data);
                        next();
                    }
                    catch (err) {
                        if (err instanceof plugins_1.AuthenticatorNotRegistered) {
                            throw err;
                        }
                        if (this.onAuthenticationFatalError) {
                            yield this.onAuthenticationFatalError(req, res, err, currentAuthenticatorName);
                        }
                    }
                });
            }
            function catchBodyParserErrors(err, req, res, next) {
                if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {
                    res.status(400).send({
                        body: req.body,
                        error: 'invalid_body'
                    });
                }
                else {
                    next(err);
                }
            }
            function listen() {
                return new Promise((resolve, reject) => {
                    this
                        .server
                        .listen(this.port, this.address, (err) => {
                        if (err) {
                            debug.normal('.listen error', err);
                            return reject(err);
                        }
                        if (listenProperties.bootMessage === undefined) {
                            console.log(`SakuraAPI started on: ${this.address}:${this.port}`.green);
                        }
                        else {
                            const msg = (listenProperties.bootMessage === '')
                                ? false
                                : listenProperties.bootMessage;
                            if (msg) {
                                process.stdout.write(`${msg}`.green);
                            }
                        }
                        debug.normal(`.listen server started ${this.address}:${this.port}`);
                        return resolve();
                    });
                });
            }
            function handleResponseLocals(req, res, next) {
                if (req.body && !res.locals.reqBody) {
                    res.locals.reqBody = req.body;
                }
                res.locals.data = {};
                res.locals.status = 200;
                res.locals.send = (status, data) => {
                    res.locals.status = status;
                    if (!res.locals.data || Object.keys(res.locals.data || {}).length === 0) {
                        res.locals.data = data;
                        return res.locals;
                    }
                    res.locals.data = Object.assign(res.locals.data, JSON.parse(JSON.stringify(data)));
                    return res.locals;
                };
                next();
            }
            function resLocalsHandler(req, res, next) {
                if (res.headersSent) {
                    return next();
                }
                res
                    .status(res.locals.status || 200)
                    .json(res.locals.data);
                next();
            }
        });
    }
    getAuthenticator(target) {
        debug.authenticators(`.getAuthenticator ${(target || {}).name}`);
        if (!target || !target[plugins_1.authenticatorPluginSymbols.isAuthenticator]) {
            throw new plugins_1.AuthenticatorsMustBeDecoratedWithAuthenticatorPluginError(target);
        }
        const id = target[plugins_1.authenticatorPluginSymbols.id];
        const authenticator = this.authenticators.get(id);
        if (!authenticator) {
            throw new plugins_1.AuthenticatorNotRegistered(target);
        }
        return authenticator;
    }
    getModelByName(name) {
        return this.models.get(name);
    }
    getProvider(target) {
        debug.providers(`.getProvider ${(target || {}).name}`);
        if (!target || !target[_1.injectableSymbols.isSakuraApiInjectable]) {
            throw new _1.ProvidersMustBeDecoratedWithInjectableError(target);
        }
        const provider = this.providers.get(target[_1.injectableSymbols.id]);
        if (!provider) {
            throw new _1.ProviderNotRegistered(target);
        }
        if (!provider.instance) {
            debug.providers(`\t lazy instantiating singleton instance of ${(target || {}).name}`);
            provider.instance = new provider.target();
        }
        return provider.instance;
    }
    getRoutableByName(name) {
        return this.routables.get(name);
    }
    enqueueRoutes(target) {
        debug.route(`SakuraApi.route called for %o`, target);
        if (!target[_routable_1.routableSymbols.routes]) {
            debug.route(`.route '%o' is not a routable class`, target);
            return;
        }
        for (const route of target[_routable_1.routableSymbols.routes]) {
            debug.route(`\tadded '%o'`, route);
            const routeSignature = `${route.httpMethod}:${route.path}`;
            if (this.routeQueue.get(routeSignature)) {
                throw new Error(`Duplicate route (${routeSignature}) registered by ${target.name || target.constructor.name}.`);
            }
            this.routeQueue.set(routeSignature, route);
        }
    }
    registerAuthenticators(options, sapiOptions) {
        debug.normal('\tRegistering Authenticators');
        const authenticators = options.authenticators || [];
        if (authenticators.length > 0 && !(sapiOptions || {}).suppressAnonymousAuthenticatorInjection) {
            this.authenticators.set(plugins_1.Anonymous[plugins_1.authenticatorPluginSymbols.id], new plugins_1.Anonymous());
        }
        for (const authenticator of authenticators) {
            const isAuthenticator = (authenticator.constructor || {})[plugins_1.authenticatorPluginSymbols.isAuthenticator];
            let authenticatorSource;
            let authenticatorRef;
            if (!isAuthenticator) {
                const mockAuthenticator = authenticator;
                if (!mockAuthenticator.use
                    || !mockAuthenticator.for
                    || !mockAuthenticator.use[_1.injectableSymbols.isSakuraApiInjectable]
                    || !mockAuthenticator.for[_1.injectableSymbols.isSakuraApiInjectable]) {
                    throw new Error('SakuraApi setup error. SakuraApiOptions.authenticators array must have classes decorated with'
                        + ' @AuthenticatorPlugin() or an object literal of the form { use: SomeMockAuthenticatorPlugin, for: SomeAuthenticatorPlugin },'
                        + ' where SomeMockAuthenticatorPlugin and SomeAuthenticatorPlugin are decorated with @AuthenticatorPlugin().');
                }
                authenticatorSource = mockAuthenticator.for;
                authenticatorRef = mockAuthenticator.use;
            }
            else {
                authenticatorSource = authenticator;
                authenticatorRef = authenticator;
            }
            authenticatorRef[plugins_1.authenticatorPluginSymbols.sapi] = this;
            debug.authenticators(`registering authenticator ${(authenticatorRef || {}).name}`);
            const id = (authenticatorSource.constructor || {})[plugins_1.authenticatorPluginSymbols.id];
            this.authenticators.set(id, authenticatorRef);
        }
    }
    registerModels(options) {
        debug.normal('\tRegistering Models');
        const models = options.models || [];
        for (const model of models) {
            const isModel = model[_model_1.modelSymbols.isSakuraApiModel];
            let modelName;
            let modelRef;
            if (!isModel) {
                if (!model.use
                    || !model.for
                    || !model.use[_model_1.modelSymbols.isSakuraApiModel]
                    || !model.for[_model_1.modelSymbols.isSakuraApiModel]) {
                    throw new Error('SakuraApi setup error. SakuraApiOptions.models array must have classes decorated with @Model'
                        + ' or an object literal of the form { use: SomeMockModel, for: SomeRealModel }, where SomeMockModel and'
                        + ' SomeRealModel are decorated with @Model.');
                }
                modelName = model.for.name;
                modelRef = model.use;
            }
            else {
                modelName = model.name;
                modelRef = model;
            }
            modelRef[_model_1.modelSymbols.sapi] = this;
            debug.models(`registering models ${(modelRef || {}).name}`);
            this.models.set(modelName, modelRef);
        }
    }
    registerPlugins(options) {
        debug.normal('\tRegistering Modules');
        const plugins = options.plugins || [];
        for (const plugin of plugins) {
            if (typeof plugin.plugin !== 'function') {
                throw new Error('SakuraApi setup error. SakuraApiOptions.plugin array must have objects with a plugin ' +
                    'property that is a function, which accepts an instance of SakuraApi. The module throwing this error is ' +
                    `a ${typeof plugin.plugin} rather than a function.`);
            }
            const pluginResults = plugin.plugin(this, plugin.options);
            this.registerModels(pluginResults);
            this.registerProviders(pluginResults);
            this.registerRoutables(pluginResults);
            this.registerAuthenticators(pluginResults, options);
            if (pluginResults.middlewareHandlers) {
                for (const handler of pluginResults.middlewareHandlers) {
                    this.addMiddleware(handler, plugin.order || 0);
                }
            }
        }
    }
    registerProviders(options) {
        debug.normal('\tRegistering Providers');
        const injectables = options.providers || [];
        for (const injectable of injectables) {
            const isInjectable = injectable[_1.injectableSymbols.isSakuraApiInjectable];
            let injectableSource;
            let injectableRef;
            if (!isInjectable) {
                if (!injectable.use
                    || !injectable.for
                    || !injectable.use[_1.injectableSymbols.isSakuraApiInjectable]
                    || !injectable.for[_1.injectableSymbols.isSakuraApiInjectable]) {
                    throw new Error('SakuraApi setup error. SakuraApiOptions.providers array must have classes decorated with'
                        + ' @Injectable or an object literal of the form { use: SomeInjectableService, for: SomeRealService },'
                        + ' where SomeMockInjectable and SomeRealInjectable are decorated with @Injectable.');
                }
                injectableSource = injectable.for;
                injectableRef = injectable.use;
            }
            else {
                injectableSource = injectable;
                injectableRef = injectable;
            }
            injectableRef[_1.injectableSymbols.sapi] = this;
            debug.providers(`registering provider ${(injectableRef || {}).name}`);
            this.providers.set(injectableSource[_1.injectableSymbols.id], {
                instance: null,
                target: injectableRef
            });
        }
    }
    registerRoutables(options) {
        debug.normal('\tRegistering Models');
        const routables = options.routables || [];
        for (const routable of routables) {
            const isRoutable = routable[_routable_1.routableSymbols.isSakuraApiRoutable];
            let routableName;
            let routableRef;
            if (!isRoutable) {
                if (!routable.use
                    || !routable.for
                    || !routable.use[_routable_1.routableSymbols.isSakuraApiRoutable]
                    || !routable.for[_routable_1.routableSymbols.isSakuraApiRoutable]) {
                    throw new Error('SakuraApi setup error. SakuraApiOptions.routables array must have classes decorated with '
                        + ' @Routable or an object literal of the form { use: SomeMockRoutable, for: SomeRealRoutable }, where'
                        + ' SomeMockRoutable and SomeRealRoutable are decorated with @Model.');
                }
                routableName = routable.for.name;
                routableRef = routable.use;
            }
            else {
                routableName = routable.name;
                routableRef = routable;
            }
            routableRef[_routable_1.routableSymbols.sapi] = this;
            this.enqueueRoutes(new routableRef());
            debug.providers(`registering routable ${(routableRef || {}).name}`);
            this.routables.set(routableName, routableRef);
        }
    }
}
exports.SakuraApi = SakuraApi;
//# sourceMappingURL=sakura-api.js.map