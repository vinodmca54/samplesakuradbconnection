"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const mongodb_1 = require("mongodb");
const injectable_1 = require("../@injectable/injectable");
const helpers_1 = require("../helpers");
const db_1 = require("./db");
const errors_1 = require("./errors");
const json_1 = require("./json");
const private_1 = require("./private");
const debug = {
    normal: require('debug')('sapi:model')
};
exports.modelSymbols = {
    constructor: Symbol('constructor'),
    dbCollection: Symbol('dbCollection'),
    dbName: Symbol('dbName'),
    fromDb: Symbol('fromDb'),
    fromDbArray: Symbol('fromDbArray'),
    fromJson: Symbol('fromJson'),
    fromJsonArray: Symbol('fromJsonArray'),
    fromJsonToDb: Symbol('fromJsonToDb'),
    isSakuraApiModel: Symbol('isSakuraApiModel'),
    modelOptions: Symbol('modelOptions'),
    sapi: Symbol('sapi'),
    toDb: Symbol('toDb'),
    toJson: Symbol('toJson'),
    toJsonString: Symbol('toJsonString')
};
function Model(modelOptions) {
    modelOptions = modelOptions || {};
    return (target) => {
        const newConstructor = new Proxy(target, {
            construct: (t, args, nt) => {
                const diArgs = injectable_1.getDependencyInjections(target, t, target[exports.modelSymbols.sapi]);
                const c = Reflect.construct(t, diArgs, nt);
                newConstructor.prototype._id = null;
                Reflect.defineProperty(c, 'id', {
                    configurable: true,
                    enumerable: false,
                    get: () => c._id,
                    set: (v) => c._id = v
                });
                if (modelOptions.dbConfig) {
                    if (!target[exports.modelSymbols.dbName]) {
                        throw new Error(`If you define a dbConfig for a model, you must define a db. target: ${target}`);
                    }
                    if (!target[exports.modelSymbols.dbCollection]) {
                        throw new Error(`If you define a dbConfig for a model, you must define a collection. target: ${target}`);
                    }
                }
                return c;
            }
        });
        Reflect.defineProperty(newConstructor.prototype, exports.modelSymbols.isSakuraApiModel, {
            value: true,
            writable: false
        });
        Reflect.defineProperty(newConstructor, exports.modelSymbols.isSakuraApiModel, {
            value: true,
            writable: false
        });
        newConstructor[exports.modelSymbols.modelOptions] = modelOptions;
        newConstructor.prototype[exports.modelSymbols.constructor] = newConstructor;
        newConstructor[exports.modelSymbols.dbName] = (modelOptions.dbConfig || {}).db || null;
        newConstructor[exports.modelSymbols.dbCollection] = (modelOptions.dbConfig || {}).collection || null;
        helpers_1.addDefaultStaticMethods(newConstructor, removeAll, modelOptions);
        helpers_1.addDefaultStaticMethods(newConstructor, removeById, modelOptions);
        helpers_1.addDefaultStaticMethods(newConstructor, get, modelOptions);
        helpers_1.addDefaultStaticMethods(newConstructor, getOne, modelOptions);
        helpers_1.addDefaultStaticMethods(newConstructor, getById, modelOptions);
        helpers_1.addDefaultStaticMethods(newConstructor, getCursor, modelOptions);
        helpers_1.addDefaultStaticMethods(newConstructor, getCursorById, modelOptions);
        helpers_1.addDefaultStaticMethods(newConstructor, getCollection, modelOptions);
        helpers_1.addDefaultStaticMethods(newConstructor, getDb, modelOptions);
        newConstructor.fromDb = fromDb;
        newConstructor[exports.modelSymbols.fromDb] = fromDb;
        newConstructor.fromDbArray = fromDbArray;
        newConstructor[exports.modelSymbols.fromDbArray] = fromDbArray;
        newConstructor.fromJson = fromJson;
        newConstructor[exports.modelSymbols.fromJson] = fromJson;
        newConstructor.fromJsonArray = fromJsonArray;
        newConstructor[exports.modelSymbols.fromJsonArray] = fromJsonArray;
        newConstructor.fromJsonToDb = fromJsonToDb;
        newConstructor[exports.modelSymbols.fromJsonToDb] = fromJsonToDb;
        newConstructor[exports.modelSymbols.sapi] = null;
        Reflect.defineProperty(newConstructor, 'sapi', {
            configurable: false,
            enumerable: false,
            get: () => newConstructor[exports.modelSymbols.sapi]
        });
        Reflect.defineProperty(newConstructor.prototype, 'sapi', {
            configurable: false,
            enumerable: false,
            get: () => newConstructor[exports.modelSymbols.sapi]
        });
        Reflect.defineProperty(newConstructor, 'sapiConfig', {
            configurable: false,
            enumerable: false,
            get: () => (newConstructor[exports.modelSymbols.sapi] || {}).config
        });
        Reflect.defineProperty(newConstructor.prototype, 'sapiConfig', {
            configurable: false,
            enumerable: false,
            get: () => (newConstructor[exports.modelSymbols.sapi] || {}).config
        });
        helpers_1.addDefaultInstanceMethods(newConstructor, create, modelOptions);
        helpers_1.addDefaultInstanceMethods(newConstructor, getCollection, modelOptions);
        helpers_1.addDefaultInstanceMethods(newConstructor, getDb, modelOptions);
        helpers_1.addDefaultInstanceMethods(newConstructor, remove, modelOptions);
        helpers_1.addDefaultInstanceMethods(newConstructor, save, modelOptions);
        newConstructor.prototype.toDb = toDb;
        newConstructor.prototype[exports.modelSymbols.toDb] = toDb;
        newConstructor.prototype.toJson = toJson;
        newConstructor.prototype[exports.modelSymbols.toJson] = toJson;
        newConstructor.prototype.toJsonString = toJsonString;
        newConstructor.prototype[exports.modelSymbols.toJsonString] = toJsonString;
        return newConstructor;
    };
}
exports.Model = Model;
function create(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const constructor = this.constructor;
        const col = constructor.getCollection();
        debug
            .normal(`.create called, dbName: '${constructor[exports.modelSymbols.dbName].name}', found?: ${!!col}, set: %O`, this);
        if (!col) {
            throw new Error(`Database '${constructor[exports.modelSymbols.dbName].name}' not found`);
        }
        const dbObj = this.toDb();
        const result = yield col.insertOne(dbObj, options);
        this.id = result.insertedId;
        return result;
    });
}
function fromDb(json, options) {
    const modelName = this.name;
    debug.normal(`.fromDb called, target '${modelName}'`);
    if (!json || typeof json !== 'object') {
        return null;
    }
    options = options || {};
    const obj = new this();
    const result = mapDbToModel(json, obj, keyMapper.bind(this));
    if (!result._id && json._id) {
        result._id = json._id;
    }
    if (result._id && !(result._id instanceof mongodb_1.ObjectID) && mongodb_1.ObjectID.isValid(result._id)) {
        result._id = new mongodb_1.ObjectID(result._id.toString());
    }
    if (options.strict) {
        pruneNonDbProperties(json, result);
    }
    if (result._id === null) {
        result._id = undefined;
    }
    return result;
    function mapDbToModel(source, target, map, depth = 0) {
        target = target || {};
        if (!source) {
            return source;
        }
        const dbOptionsByFieldName = Reflect.getMetadata(db_1.dbSymbols.dbByFieldName, target) || new Map();
        const propertyNames = Object.getOwnPropertyNames(source);
        for (const key of propertyNames) {
            const mapper = map(key, source[key], dbOptionsByFieldName);
            const model = mapper.model;
            let nextTarget;
            try {
                nextTarget = (model)
                    ? Object.assign(new model(), target[mapper.newKey])
                    : target[mapper.newKey];
            }
            catch (err) {
                throw new Error(`Model '${modelName}' has a property '${key}' that defines its model with a value that`
                    + ` cannot be constructed`);
            }
            if (helpers_1.shouldRecurse(source[key])) {
                if (mapper.newKey !== undefined) {
                    let value = mapDbToModel(source[key], nextTarget, map, ++depth);
                    if (model) {
                        value = Object.assign(new model(), value);
                        if (depth > 0 && (!value.id || !value._id)) {
                            value._id = undefined;
                        }
                    }
                    target[mapper.newKey] = value;
                }
            }
            else {
                if (mapper.newKey !== undefined) {
                    target[mapper.newKey] = (source[key] !== undefined && source[key] !== null)
                        ? source[key]
                        : nextTarget;
                }
            }
        }
        return target;
    }
    function keyMapper(key, value, meta) {
        const dbFieldOptions = (meta) ? meta.get(key) : null;
        return {
            model: ((dbFieldOptions || {}).model),
            newKey: (dbFieldOptions)
                ? dbFieldOptions[db_1.dbSymbols.propertyName]
                : ((this[exports.modelSymbols.modelOptions].dbConfig || {}).promiscuous)
                    ? key
                    : undefined
        };
    }
    function pruneNonDbProperties(source, target) {
        const dbOptionsByProperty = Reflect.getMetadata(db_1.dbSymbols.dbByPropertyName, target);
        const keys = Object.getOwnPropertyNames(target);
        for (const key of keys) {
            const dbOptions = (dbOptionsByProperty) ? dbOptionsByProperty.get(key) || {} : null;
            const fieldName = (dbOptions) ? dbOptions.field || key : key;
            if (!!source && !source.hasOwnProperty(fieldName)) {
                if (key === 'id' && source.hasOwnProperty('_id')) {
                    continue;
                }
                delete target[key];
                continue;
            }
            if (typeof target[key] === 'object' && !(target[key] instanceof mongodb_1.ObjectID) && target[key] !== null) {
                pruneNonDbProperties(source[fieldName], target[key]);
            }
        }
    }
}
function fromDbArray(jsons, options) {
    debug.normal(`.fromDbArray called, target '${this.name}'`);
    if (!jsons || !Array.isArray(jsons)) {
        return [];
    }
    const results = [];
    for (const json of jsons) {
        const obj = this.fromDb(json, options);
        if (obj) {
            results.push(obj);
        }
    }
    return results;
}
function fromJson(json) {
    const modelName = this.name;
    debug.normal(`.fromJson called, target '${modelName}'`);
    if (!json || typeof json !== 'object') {
        return null;
    }
    const obj = new this();
    return mapJsonToModel(json, obj);
    function mapJsonToModel(jsonSource, target) {
        target = target || {};
        if (!jsonSource) {
            return jsonSource;
        }
        const propertyNamesByJsonFieldName = Reflect.getMetadata(json_1.jsonSymbols.jsonByFieldName, target) || new Map();
        const propertyNamesByDbPropertyName = Reflect.getMetadata(db_1.dbSymbols.dbByPropertyName, target) || new Map();
        const propertyNames = Object.getOwnPropertyNames(jsonSource);
        for (const key of propertyNames) {
            const mapper = keyMapper(key, jsonSource[key], propertyNamesByJsonFieldName, target);
            if (mapper.promiscuous) {
                target[mapper.newKey] = jsonSource[key];
            }
            else if (helpers_1.shouldRecurse(jsonSource[key])) {
                const dbModel = propertyNamesByDbPropertyName.get(mapper.newKey) || {};
                if (mapper.newKey !== undefined) {
                    const model = mapper.model || (dbModel || {}).model || null;
                    let nextTarget;
                    try {
                        nextTarget = (model)
                            ? Object.assign(new model(), target[mapper.newKey])
                            : target[mapper.newKey];
                    }
                    catch (err) {
                        throw new Error(`Model '${modelName}' has a property '${key}' that defines its model with a value that`
                            + ` cannot be constructed`);
                    }
                    let value = mapJsonToModel(jsonSource[key], nextTarget);
                    if (model) {
                        value = Object.assign(new model(), value);
                    }
                    target[mapper.newKey] = value;
                }
            }
            else {
                if (mapper.newKey !== undefined) {
                    let value = jsonSource[key];
                    if ((mapper.newKey === 'id' || mapper.newKey === '_id') && mongodb_1.ObjectID.isValid(value)) {
                        value = new mongodb_1.ObjectID(value);
                    }
                    target[mapper.newKey] = value;
                }
            }
        }
        return target;
    }
    function keyMapper(key, value, meta, target) {
        const jsonFieldOptions = (meta) ? meta.get(key) : null;
        const model = (jsonFieldOptions || {}).model;
        return {
            model,
            newKey: (jsonFieldOptions)
                ? jsonFieldOptions[json_1.jsonSymbols.propertyName]
                : (target[key])
                    ? key
                    : (key === 'id' || key === '_id')
                        ? key
                        : undefined,
            promiscuous: (jsonFieldOptions || {}).promiscuous || false
        };
    }
}
function fromJsonArray(json) {
    debug.normal(`.fromJsonArray called, target '${this.name}'`);
    const result = [];
    if (Array.isArray(json)) {
        for (const item of json) {
            result.push(this[exports.modelSymbols.fromJson](item));
        }
    }
    return result;
}
function fromJsonToDb(json, ...constructorArgs) {
    const modelName = this.name;
    debug.normal(`.fromJsonToDb called, target '${modelName}'`);
    if (!json || typeof json !== 'object') {
        return null;
    }
    return mapJsonToDb(new this(...constructorArgs), json);
    function mapJsonToDb(model, jsonSrc, result) {
        const dbByPropertyName = Reflect.getMetadata(db_1.dbSymbols.dbByPropertyName, model);
        const jsonByPropertyName = Reflect.getMetadata(json_1.jsonSymbols.jsonByPropertyName, model);
        const isRoot = !!result;
        result = result || {};
        if (jsonSrc && jsonSrc.id !== undefined && !isRoot) {
            result._id = jsonSrc.id;
        }
        for (const key of jsonByPropertyName.keys()) {
            const dbMeta = (dbByPropertyName) ? dbByPropertyName.get(key) : null;
            const jsonMeta = (jsonByPropertyName) ? jsonByPropertyName.get(key) : null;
            if (!jsonSrc || !jsonMeta || !dbMeta) {
                continue;
            }
            if (helpers_1.shouldRecurse(model[key])) {
                const value = mapJsonToDb(model[key], jsonSrc[jsonMeta.field || key], result[dbMeta.field || key]);
                if (value && Object.keys(value).length > 0) {
                    result[dbMeta.field || key] = value;
                }
            }
            else {
                const value = jsonSrc[jsonMeta.field || key];
                if (value !== undefined && value !== null) {
                    result[dbMeta.field || key] = value;
                }
            }
        }
        return result;
    }
}
function get(params) {
    return __awaiter(this, void 0, void 0, function* () {
        debug.normal(`.get called, dbName '${this[exports.modelSymbols.dbName]}'`);
        const cursor = this.getCursor(params.filter, params.project);
        if (params) {
            if (params.skip) {
                cursor.skip(params.skip);
            }
            if (params.limit) {
                cursor.limit(params.limit);
            }
        }
        const results = yield cursor.toArray();
        const options = (params.project) ? { strict: true } : null;
        const objs = [];
        for (const result of results) {
            const obj = this.fromDb(result, options);
            if (obj) {
                objs.push(obj);
            }
        }
        return objs;
    });
}
function getById(id, project) {
    return __awaiter(this, void 0, void 0, function* () {
        debug.normal(`.getById called, dbName '${this[exports.modelSymbols.dbName]}'`);
        const cursor = this.getCursorById(id, project);
        const options = (project) ? { strict: true } : null;
        const result = yield cursor.next();
        return this.fromDb(result, options);
    });
}
function getCollection() {
    const constructor = this[exports.modelSymbols.constructor] || this;
    const db = constructor.getDb();
    if (!db) {
        return null;
    }
    const col = db.collection(constructor[exports.modelSymbols.dbCollection]);
    debug.normal(`.getCollection called, dbName: '${constructor[exports.modelSymbols.dbName]},` +
        ` collection: ${constructor[exports.modelSymbols.dbCollection]}', found?: ${!!col}`);
    return col;
}
function getCursor(filter, project) {
    filter = filter || {};
    const col = this.getCollection();
    debug.normal(`.getCursor called, dbName '${this[exports.modelSymbols.dbName]}', found?: ${!!col}`);
    if (!col) {
        throw new Error(`Database '${this[exports.modelSymbols.dbName]}' not found`);
    }
    if (filter._id && !(filter._id instanceof mongodb_1.ObjectID) && mongodb_1.ObjectID.isValid(filter._id)) {
        filter._id = new mongodb_1.ObjectID(filter._id.toString());
    }
    return (project)
        ? col.find(filter).project(project)
        : col.find(filter);
}
function getCursorById(id, project) {
    debug.normal(`.getCursorById called, dbName '${this[exports.modelSymbols.dbName]}'`);
    return this
        .getCursor({
        _id: (id instanceof mongodb_1.ObjectID) ? id : id.toString() || `${id}`
    }, project)
        .limit(1);
}
function getDb() {
    const constructor = this[exports.modelSymbols.constructor] || this;
    if (!constructor.sapi) {
        const target = constructor.name || constructor.constructor.name;
        throw new Error(`getDb called on model ${target} without an instance of ` +
            `SakuraAPI. Make sure you pass ${target} into the Model injector when you're ` +
            `instantiating SakuraApi`);
    }
    const db = constructor[exports.modelSymbols.sapi].dbConnections.getDb(constructor[exports.modelSymbols.dbName]);
    debug.normal(`.getDb called, dbName: '${constructor[exports.modelSymbols.dbName]}', found?: ${!!db}`);
    if (!db) {
        throw new errors_1.SapiDbForModelNotFound(constructor.name, constructor[exports.modelSymbols.dbName]);
    }
    return db;
}
function getOne(filter, project) {
    return __awaiter(this, void 0, void 0, function* () {
        const cursor = this.getCursor(filter, project);
        debug.normal(`.getOne called, dbName '${this[exports.modelSymbols.dbName]}'`);
        const result = yield cursor
            .limit(1)
            .next();
        const obj = this.fromDb(result);
        return obj;
    });
}
function remove(options) {
    const constructor = this.constructor;
    debug.normal(`.remove called for ${this.id}`);
    return constructor.removeById(this.id, options);
}
function removeAll(filter, options) {
    const col = this.getCollection();
    debug.normal(`.removeAll called, dbName: '${this[exports.modelSymbols.dbName]}', found?: ${!!col}, id: %O`, this.id);
    if (!col) {
        throw new Error(`Database '${this[exports.modelSymbols.dbName]}' not found`);
    }
    return col.deleteMany(filter, options);
}
function removeById(id, options) {
    const col = this.getCollection();
    if (!(id instanceof mongodb_1.ObjectID)) {
        id = (mongodb_1.ObjectID.isValid(id)) ? new mongodb_1.ObjectID(id) : id;
    }
    debug.normal(`.removeById called, dbName: '${this[exports.modelSymbols.dbName]}', found?: ${!!col}, id: %O`, id);
    if (!col) {
        throw new Error(`Database '${this[exports.modelSymbols.dbName]}' not found`);
    }
    if (!id) {
        return Promise.reject(new errors_1.SapiMissingIdErr('Call to delete without Id, cannot proceed', this));
    }
    return col.deleteOne({ _id: id }, options);
}
function save(changeSet, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const constructor = this.constructor;
        const col = constructor.getCollection();
        debug.normal(`.save called, dbName: '${constructor[exports.modelSymbols.dbName]}', found?: ${!!col}, set: %O`, changeSet);
        if (!col) {
            throw new Error(`Database '${constructor[exports.modelSymbols.dbName]}' not found`);
        }
        if (!this.id) {
            return Promise.reject(new errors_1.SapiMissingIdErr('Model missing id field, cannot save. Did you mean ' +
                'to use create?', this));
        }
        const dbObj = changeSet || this.toDb(this);
        delete dbObj._id;
        delete dbObj.id;
        const result = yield col.updateOne({ _id: this.id }, { $set: dbObj }, options);
        if (changeSet) {
            const modelMappedChangeSet = this.constructor.fromDb(changeSet, { strict: true });
            for (const key of Object.getOwnPropertyNames(modelMappedChangeSet)) {
                if (key === '_id' || key === 'id') {
                    continue;
                }
                this[key] = modelMappedChangeSet[key];
            }
        }
        return result;
    });
}
function toDb(changeSet) {
    const constructor = this[exports.modelSymbols.constructor] || this;
    const modelOptions = constructor[exports.modelSymbols.modelOptions];
    debug.normal(`.toDb called, target '${constructor.name}'`);
    changeSet = changeSet || this;
    const dbObj = mapModelToDb(changeSet);
    delete dbObj.id;
    if (!dbObj._id && this._id) {
        dbObj._id = this._id;
    }
    return dbObj;
    function mapModelToDb(source, depth = 0) {
        const result = {};
        if (!source) {
            return;
        }
        const dbOptionsByPropertyName = Reflect.getMetadata(db_1.dbSymbols.dbByPropertyName, source);
        for (const key of Object.getOwnPropertyNames(source)) {
            if (helpers_1.shouldRecurse(source[key])) {
                const aNewKey = keyMapper(key, source[key], dbOptionsByPropertyName);
                if (aNewKey !== undefined) {
                    const value = mapModelToDb(source[key], ++depth);
                    result[aNewKey] = value;
                }
                continue;
            }
            const newKey = keyMapper(key, source[key], dbOptionsByPropertyName);
            if (newKey !== undefined) {
                result[newKey] = source[key];
            }
        }
        if (depth > 0 && !result.id) {
            delete result.id;
        }
        if (depth > 0 && !result._id) {
            delete result._id;
        }
        if (depth > 0 && (result._id && result.id)) {
            delete result.id;
        }
        return result;
    }
    function keyMapper(key, value, dbMeta) {
        if (!dbMeta) {
            dbMeta = constructor[db_1.dbSymbols.dbByPropertyName];
        }
        let fieldName;
        if (dbMeta && dbMeta.get) {
            const dbOptions = (dbMeta.get(key));
            if ((dbOptions || {}).field) {
                fieldName = dbOptions.field;
            }
            else if (dbOptions) {
                fieldName = key;
            }
        }
        if (!fieldName && (modelOptions.dbConfig || {}).promiscuous) {
            fieldName = key;
        }
        return fieldName;
    }
}
function toJson() {
    debug.normal(`.toJson called, target '${this.constructor.name}'`);
    const obj = mapModelToJson(this);
    return obj;
    function mapModelToJson(source) {
        const result = {};
        if (!source) {
            return source;
        }
        let jsonFieldNamesByProperty = Reflect.getMetadata(json_1.jsonSymbols.jsonByPropertyName, source);
        jsonFieldNamesByProperty = jsonFieldNamesByProperty || new Map();
        const dbOptionsByPropertyName = Reflect.getMetadata(db_1.dbSymbols.dbByPropertyName, source);
        const privateFields = Reflect.getMetadata(private_1.privateSymbols.sakuraApiPrivatePropertyToFieldNames, source);
        for (const key of Object.getOwnPropertyNames(source)) {
            if (typeof source[key] === 'function') {
                continue;
            }
            if (key === '_id') {
                continue;
            }
            if (dbOptionsByPropertyName) {
                const dbOptions = dbOptionsByPropertyName.get(key);
                if ((dbOptions || {}).private) {
                    continue;
                }
            }
            const override = (privateFields) ? privateFields.get(key) : null;
            if (override && typeof source[override] === 'function' && !source[override]()) {
                continue;
            }
            else if (override && !source[override]) {
                continue;
            }
            if (helpers_1.shouldRecurse(source[key])) {
                const aNewKey = keyMapper(key, source[key], jsonFieldNamesByProperty);
                if (aNewKey !== undefined) {
                    const value = mapModelToJson(source[key]);
                    result[aNewKey] = value;
                }
                continue;
            }
            const newKey = keyMapper(key, source[key], jsonFieldNamesByProperty);
            if (newKey !== undefined) {
                result[newKey] = source[key];
            }
        }
        return result;
    }
    function keyMapper(key, value, jsonMeta) {
        const options = (jsonMeta) ? jsonMeta.get(key) || {} : {};
        return options.field || key;
    }
}
function toJsonString(replacer, space) {
    debug.normal(`.toJsonString called, target '${this.constructor.name}'`);
    return JSON.stringify(this[exports.modelSymbols.toJson](), replacer, space);
}
//# sourceMappingURL=model.js.map